# Task Manager
Юрій Генташ

Мова програмування: Java 17+
Фреймворк: Spring

Перед запуском необхідно створити нову базу з назвою taskmanager в PostgreSQL (в H2 це відбувається автоматично).
У файлі application.yml, у разі необхідності, змінити дані про PostgreSQL.
Для запуску використовувати команду java -jar taskManager.jar
Після запуску можна виконувати запити з умови завдання на ресурс http://localhost:8080/api/v1/tasks.

Створено REST сервіс з методами відповідно до умови для сутності Task(UUID id, Status status, String description).
DDL для обох баз даних генерується автоматично на основі аннотацій сутності Task для спрощення задачі.

Згенеровану документацію можна переглянути у [Swagger](http://localhost:8080/swagger-ui.html) 
У програмі є controller, service, repository шари. З них unit-тестами на 52% покритий TaskService.
POST, PUT, PATCH містять валідацію вхідних DTO.

Методи сервісу містять невеликі інформаційні логи та логи про перемикання/синхронізацію баз даних (вивід в консоль та в файл).

З додаткових бізнес-правил додано перевірку на дублікати при створенні - task повинна бути унікальною за статусом і описом 
(хоча логічніше робити лише за описом).

Найскладнішою частиною завдання було додавання резервної бази даних.
Для цього було створено 2 DataSource, та відповідно 2 репозиторії для кожної з баз даних.
Для перемикання між базами даних створено @Scheduled метод, який з певною періодичністю робить запит
на базу даних, щоб впевнитись що вона працює (але краще добавити таку логіку і в хендлінг помилок - коли база відмовила 
і хтось надіслав запит матимемо помилку і після кількох спроб можна перемикати бази). 
У разі її відмови, програма починає працювати з репозиторієм резервної бази даних. @Scheduled метод продовжуватиме 
пінгувати базу, щоб перемкнутись назад в разі її відновлення.

При цьому, важливо зберігати однакові дані в обох базах. Тому при перемиканні баз в обов'язковому порядку
запускається механізм синхронізації даних (він періодично запускається сам, але при перемиканні ми змушуємо його відпрацювати).
Для цього в програмі є 2 впорядкованих списки create/update/delete івентів List<CudEvent>. У звичайному режимі
програма записує дані лише в одну базу, а для іншої додає в її список івент про це. Далі @Scheduled метод перевіряє 
наявність івентів в списках і виконує відповідні запити на другу базу, після чого очищає список. 
Завдяки такому підходу все що відбулось з основною базою відбудеться і з резервною в тій же послідовності 
(Це спрощений варіант асинхронної запису в рамках тестового завдання, в реальній системі замість 
списків у пам'яті використовувався б месседжінг сервіс Kafka/RabbitMQ/...)